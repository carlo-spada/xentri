#!/usr/bin/env tsx
/**
 * sync-agent-context.ts
 *
 * Generates CLAUDE.md, GEMINI.md, and AGENTS.md from docs/governance/governance.md
 *
 * Usage:
 *   pnpm exec tsx scripts/sync-agent-context.ts
 *   pnpm run sync:agents
 *
 * This script:
 * 1. Reads governance.md as the SSOT
 * 2. Transforms it into agent-friendly format
 * 3. Writes to CLAUDE.md, GEMINI.md, AGENTS.md with generation headers
 * 4. Validates the files are in sync (for CI)
 */

import * as fs from "fs";
import * as path from "path";
import * as crypto from "crypto";

const PROJECT_ROOT = path.resolve(__dirname, "..");
const GOVERNANCE_PATH = path.join(
  PROJECT_ROOT,
  "docs/governance/governance.md"
);
const AGENT_FILES = ["CLAUDE.md", "GEMINI.md", "AGENTS.md"] as const;

type AgentFile = (typeof AGENT_FILES)[number];

const AGENT_HEADERS: Record<AgentFile, string> = {
  "CLAUDE.md": `# CLAUDE.md

<!-- DO NOT EDIT THIS FILE DIRECTLY -->
<!-- Generated from docs/governance/governance.md -->
<!-- Run: pnpm run sync:agents -->

> **Self-contained context.** This file contains complete project context for Claude Code.
> Do NOT read GEMINI.md or AGENTS.md — they contain identical information.
`,

  "GEMINI.md": `# GEMINI.md

<!-- DO NOT EDIT THIS FILE DIRECTLY -->
<!-- Generated from docs/governance/governance.md -->
<!-- Run: pnpm run sync:agents -->

> **Self-contained context.** This file contains complete project context for Gemini.
> Do NOT read CLAUDE.md or AGENTS.md — they contain identical information.
`,

  "AGENTS.md": `# AGENTS.md

<!-- DO NOT EDIT THIS FILE DIRECTLY -->
<!-- Generated from docs/governance/governance.md -->
<!-- Run: pnpm run sync:agents -->

> **Self-contained context.** This file contains complete project context for AI agents.
> Do NOT read CLAUDE.md or GEMINI.md — they contain identical information.
`,
};

function readGovernance(): string {
  if (!fs.existsSync(GOVERNANCE_PATH)) {
    console.error(`Error: ${GOVERNANCE_PATH} not found`);
    process.exit(1);
  }
  return fs.readFileSync(GOVERNANCE_PATH, "utf-8");
}

function transformForAgent(governanceContent: string): string {
  // Remove the governance-specific header and replace with agent-agnostic content
  let content = governanceContent;

  // Remove the original title and header block
  content = content.replace(
    /^# Xentri Governance\n\n>.*?(?=\n---|\n## )/s,
    ""
  );

  // Remove the "Generates:" line if present
  content = content.replace(/^>.*Generates:.*\n/gm, "");

  // Remove the Table of Contents (agents don't need navigation)
  content = content.replace(/## Table of Contents\n\n[\s\S]*?(?=\n---\n)/, "");

  // Remove "Related Documents" section (governance-specific)
  content = content.replace(/## Related Documents[\s\S]*$/, "");

  // Clean up multiple consecutive blank lines
  content = content.replace(/\n{3,}/g, "\n\n");

  // Trim whitespace
  content = content.trim();

  return content;
}

function generateAgentFile(agentFile: AgentFile, content: string): string {
  const header = AGENT_HEADERS[agentFile];
  const hash = crypto.createHash("md5").update(content).digest("hex").slice(0, 8);

  return `${header}
<!-- Content hash: ${hash} -->

${content}
`;
}

function writeAgentFiles(content: string): void {
  for (const agentFile of AGENT_FILES) {
    const filePath = path.join(PROJECT_ROOT, agentFile);
    const fileContent = generateAgentFile(agentFile, content);
    fs.writeFileSync(filePath, fileContent, "utf-8");
    console.log(`✓ Generated ${agentFile}`);
  }
}

function validateSync(): boolean {
  const governanceContent = readGovernance();
  const transformedContent = transformForAgent(governanceContent);
  const expectedHash = crypto
    .createHash("md5")
    .update(transformedContent)
    .digest("hex")
    .slice(0, 8);

  let allValid = true;

  for (const agentFile of AGENT_FILES) {
    const filePath = path.join(PROJECT_ROOT, agentFile);

    if (!fs.existsSync(filePath)) {
      console.error(`✗ ${agentFile} does not exist`);
      allValid = false;
      continue;
    }

    const fileContent = fs.readFileSync(filePath, "utf-8");
    const hashMatch = fileContent.match(/<!-- Content hash: ([a-f0-9]+) -->/);

    if (!hashMatch) {
      console.error(`✗ ${agentFile} missing content hash`);
      allValid = false;
      continue;
    }

    const actualHash = hashMatch[1];
    if (actualHash !== expectedHash) {
      console.error(
        `✗ ${agentFile} is out of sync (expected: ${expectedHash}, found: ${actualHash})`
      );
      allValid = false;
    } else {
      console.log(`✓ ${agentFile} is in sync`);
    }
  }

  return allValid;
}

function main(): void {
  const args = process.argv.slice(2);
  const validateOnly = args.includes("--validate");

  if (validateOnly) {
    console.log("Validating agent context files...\n");
    const valid = validateSync();
    process.exit(valid ? 0 : 1);
  }

  console.log("Syncing agent context files from governance.md...\n");

  const governanceContent = readGovernance();
  const transformedContent = transformForAgent(governanceContent);
  writeAgentFiles(transformedContent);

  console.log("\n✓ All agent context files generated successfully");
  console.log("  Source: docs/governance/governance.md");
}

main();
